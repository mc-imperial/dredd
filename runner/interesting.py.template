#!/usr/bin/python3

import filecmp
import os
import re
import subprocess
import sys
import time

# Check that the program compiles with a recent clang
result: subprocess.CompletedProcess = subprocess.run(["clang-14", "-I" "{{ csmith_root }}/runtime", "-I" "{{ csmith_root }}/build/runtime", "-pedantic", "-Wall", "-O0", "-c", "__prog.c"], capture_output=True)
if result.returncode != 0:
   sys.exit(1)

# Check the program is free from various telltale clang compiler warnings
output: str = result.stdout.decode('utf-8') + result.stderr.decode('utf-8')
for warning in [ "incompatible redeclaration",
   "ordered comparison between pointer",
   "eliding middle term",
   "end of non-void function",
   "invalid in C99",
   "specifies type",
   "should return a value",
   "too few argument",
   "too many argument",
   "return type of 'main"
   "uninitialized",
   "incompatible pointer to",
   "incompatible integer to",
   "type specifier missing",
   "omitting the parameter name in a function definition is a C2x extension",
   "was not declared, defaulting to type",
   "is uninitialized when used here",
   "to bit-field changes value from",
   "format string is not a string literal"]:
   if warning in output:
      sys.exit(2)

# Check the program compiles with a recent gcc
result = subprocess.run(["gcc-11", "-I" "{{ csmith_root }}/runtime", "-I" "{{ csmith_root }}/build/runtime", "-c", "-Wall", "-Wextra", "__prog.c"], capture_output=True)
if result.returncode != 0:
   sys.exit(3)

# Check the program is free from various telltale gcc compiler warnings
output: str = result.stdout.decode('utf-8') + result.stderr.decode('utf-8')
for warning in ["uninitialized",
                "control reaches end",
                "no semicolon at end",
                "incompatible pointer",
                "cast from pointer to integer",
                "ordered comparison of pointer with integer",
                "declaration does not declare anything",
                "expects type",
                "assumed to have one element",
                "division by zero",
                "pointer from integer",
                "incompatible implicit",
                "excess elements in struct initializer",
                "comparison between pointer and integer",
                "format .* expects a matching .* argument",
                "overflow in conversion from",
                "format not a string literal",
                "no return statement in function returning non-void"]:
  if re.search(warning, output):
    sys.exit(4)

# Compile with the unmutated compiler, timing how long this takes
compile_start = time.time()
result = subprocess.run(["{{ compiler_executable }}", "-I" "{{ csmith_root }}/runtime", "-I" "{{ csmith_root }}/build/runtime", "-O3", "__prog.c", "-o", "__regular"], capture_output=True)
compile_end = time.time()

# Compilation with the non-mutated compiler should succeed
if result.returncode != 0:
   sys.exit(5)

# Compile with the mutated compiler, allowing compilation to take substantially longer
try:
   dredd_environment = os.environ.copy()
   dredd_environment["DREDD_ENABLED_MUTATION"] = "{{ mutation_ids }}"
   result = subprocess.run(["{{ compiler_executable }}", "-I" "{{ csmith_root }}/runtime", "-I" "{{ csmith_root }}/build/runtime", "-O3", "__prog.c", "-o", "__mutated"],
                           capture_output=True,
                           timeout=max(5.0, 5.0*(compile_end - compile_start)),
                           env=dredd_environment)
   if result.returncode != 0:
      # Compilation with the mutated file failed, which is not
      # interesting as we are looking for a mutation-induced
      # miscompilation
      sys.exit(6)
except subprocess.TimeoutExpired:
   # Compilation with the mutated compiler timed out, which is not
   # interesting as we are looking for a mutation-induced
   # miscompilation
   sys.exit(7)

if filecmp.cmp("__regular", "__mutated"):
   # There is no difference between the binaries generated by the
   # original and mutated compilers - not interesting.
   sys.exit(8)

# Run the program compiled with the regular compiler, and time it.
try:
   execute_start = time.time()
   result_regular = subprocess.run(["./__regular"], capture_output=True, timeout=10)
   execute_end = time.time()
   if result_regular.returncode != 0:
     # Execution failed - not interesting
     sys.exit(10)
except subprocess.TimeoutExpired:
   # Execution timed out - not interesting
   sys.exit(9)

# Now try running the program compiled with the mutated compiler,
# giving it substantially more time to run.
try:
   result_mutated = subprocess.run(["./__mutated"], capture_output=True, timeout=max(10.0, 10.0*(execute_end - execute_start)))
   if result_mutated.returncode != 0:
      # The mutated program terminated anormally. Not interesting.
      sys.exit(11)

   if result_mutated.stdout.decode('utf-8') == result_regular.stdout.decode('utf-8'):
      # The mutated program yielded a result matching the regular
      # program. Not interesting.
      sys.exit(12)
except subprocess.TimeoutExpired:
   # The mutated program timed out while the original did not. Not
   # interesting.
   sys.exit(13)

# Finally, check that the program is UB-free. First, use asan and ubsan.
result = subprocess.run(["clang-14", "-I" "{{ csmith_root }}/runtime", "-I" "{{ csmith_root }}/build/runtime", "-fsanitize=address,undefined", "-fno-sanitize-recover=undefined", "__prog.c", "-o", "__sanitized"], capture_output=True)
if result.returncode != 0:
   # Compilation failed - this really shouldn't happen, but if it does then
   # something is wrong
   sys.exit(14)
result = subprocess.run(["./__sanitized"], capture_output=True)
if result.returncode != 0:
   # Either asan or ubsan detected a problem - not interesting
   sys.exit(15)

# Now use msan
result = subprocess.run(["clang-14", "-I" "{{ csmith_root }}/runtime", "-I" "{{ csmith_root }}/build/runtime", "-fsanitize=memory", "__prog.c", "-o", "__sanitized"], capture_output=True)
if result.returncode != 0:
   # Compilation failed - this really shouldn't happen, but if it does then
   # something is wrong
   sys.exit(16)
result = subprocess.run(["./__sanitized"], capture_output=True)
if result.returncode != 0:
   # msan detected a problem - not interesting
   sys.exit(17)

sys.exit(0)
